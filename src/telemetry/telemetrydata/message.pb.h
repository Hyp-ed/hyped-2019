// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace telemetry_data {
class ClientToServer;
class ClientToServerDefaultTypeInternal;
extern ClientToServerDefaultTypeInternal _ClientToServer_default_instance_;
class ClientToServer_Batteries;
class ClientToServer_BatteriesDefaultTypeInternal;
extern ClientToServer_BatteriesDefaultTypeInternal _ClientToServer_Batteries_default_instance_;
class ClientToServer_Batteries_BatteryData;
class ClientToServer_Batteries_BatteryDataDefaultTypeInternal;
extern ClientToServer_Batteries_BatteryDataDefaultTypeInternal _ClientToServer_Batteries_BatteryData_default_instance_;
class ClientToServer_EmergencyBrakes;
class ClientToServer_EmergencyBrakesDefaultTypeInternal;
extern ClientToServer_EmergencyBrakesDefaultTypeInternal _ClientToServer_EmergencyBrakes_default_instance_;
class ClientToServer_Motors;
class ClientToServer_MotorsDefaultTypeInternal;
extern ClientToServer_MotorsDefaultTypeInternal _ClientToServer_Motors_default_instance_;
class ClientToServer_Navigation;
class ClientToServer_NavigationDefaultTypeInternal;
extern ClientToServer_NavigationDefaultTypeInternal _ClientToServer_Navigation_default_instance_;
class ClientToServer_Sensors;
class ClientToServer_SensorsDefaultTypeInternal;
extern ClientToServer_SensorsDefaultTypeInternal _ClientToServer_Sensors_default_instance_;
class ClientToServer_Sensors_ImuData;
class ClientToServer_Sensors_ImuDataDefaultTypeInternal;
extern ClientToServer_Sensors_ImuDataDefaultTypeInternal _ClientToServer_Sensors_ImuData_default_instance_;
class ClientToServer_StateMachine;
class ClientToServer_StateMachineDefaultTypeInternal;
extern ClientToServer_StateMachineDefaultTypeInternal _ClientToServer_StateMachine_default_instance_;
class ClientToServer_Temperature;
class ClientToServer_TemperatureDefaultTypeInternal;
extern ClientToServer_TemperatureDefaultTypeInternal _ClientToServer_Temperature_default_instance_;
class ServerToClient;
class ServerToClientDefaultTypeInternal;
extern ServerToClientDefaultTypeInternal _ServerToClient_default_instance_;
}  // namespace telemetry_data
PROTOBUF_NAMESPACE_OPEN
template<> ::telemetry_data::ClientToServer* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer>(Arena*);
template<> ::telemetry_data::ClientToServer_Batteries* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries>(Arena*);
template<> ::telemetry_data::ClientToServer_Batteries_BatteryData* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries_BatteryData>(Arena*);
template<> ::telemetry_data::ClientToServer_EmergencyBrakes* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_EmergencyBrakes>(Arena*);
template<> ::telemetry_data::ClientToServer_Motors* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Motors>(Arena*);
template<> ::telemetry_data::ClientToServer_Navigation* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Navigation>(Arena*);
template<> ::telemetry_data::ClientToServer_Sensors* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors>(Arena*);
template<> ::telemetry_data::ClientToServer_Sensors_ImuData* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors_ImuData>(Arena*);
template<> ::telemetry_data::ClientToServer_StateMachine* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_StateMachine>(Arena*);
template<> ::telemetry_data::ClientToServer_Temperature* Arena::CreateMaybeMessage<::telemetry_data::ClientToServer_Temperature>(Arena*);
template<> ::telemetry_data::ServerToClient* Arena::CreateMaybeMessage<::telemetry_data::ServerToClient>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace telemetry_data {

enum ServerToClient_Command : int {
  ServerToClient_Command_ACK = 0,
  ServerToClient_Command_STOP = 1,
  ServerToClient_Command_CALIBRATE = 2,
  ServerToClient_Command_LAUNCH = 3,
  ServerToClient_Command_RESET = 4,
  ServerToClient_Command_SERVICE_PROPULSION_GO = 5,
  ServerToClient_Command_SERVICE_PROPULSION_STOP = 6,
  ServerToClient_Command_NOMINAL_BRAKING = 7,
  ServerToClient_Command_ServerToClient_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServerToClient_Command_ServerToClient_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServerToClient_Command_IsValid(int value);
constexpr ServerToClient_Command ServerToClient_Command_Command_MIN = ServerToClient_Command_ACK;
constexpr ServerToClient_Command ServerToClient_Command_Command_MAX = ServerToClient_Command_NOMINAL_BRAKING;
constexpr int ServerToClient_Command_Command_ARRAYSIZE = ServerToClient_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerToClient_Command_descriptor();
template<typename T>
inline const std::string& ServerToClient_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerToClient_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerToClient_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerToClient_Command_descriptor(), enum_t_value);
}
inline bool ServerToClient_Command_Parse(
    const std::string& name, ServerToClient_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerToClient_Command>(
    ServerToClient_Command_descriptor(), name, value);
}
enum ClientToServer_StateMachine_State : int {
  ClientToServer_StateMachine_State_INVALID = 0,
  ClientToServer_StateMachine_State_IDLE = 1,
  ClientToServer_StateMachine_State_CALIBRATING = 2,
  ClientToServer_StateMachine_State_READY = 3,
  ClientToServer_StateMachine_State_ACCELERATING = 4,
  ClientToServer_StateMachine_State_NOMINAL_BRAKING = 5,
  ClientToServer_StateMachine_State_EMERGENCY_BRAKING = 6,
  ClientToServer_StateMachine_State_RUN_COMPLETE = 7,
  ClientToServer_StateMachine_State_FAILURE_STOPPED = 8,
  ClientToServer_StateMachine_State_EXITING = 9,
  ClientToServer_StateMachine_State_FINISHED = 10,
  ClientToServer_StateMachine_State_ClientToServer_StateMachine_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientToServer_StateMachine_State_ClientToServer_StateMachine_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientToServer_StateMachine_State_IsValid(int value);
constexpr ClientToServer_StateMachine_State ClientToServer_StateMachine_State_State_MIN = ClientToServer_StateMachine_State_INVALID;
constexpr ClientToServer_StateMachine_State ClientToServer_StateMachine_State_State_MAX = ClientToServer_StateMachine_State_FINISHED;
constexpr int ClientToServer_StateMachine_State_State_ARRAYSIZE = ClientToServer_StateMachine_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientToServer_StateMachine_State_descriptor();
template<typename T>
inline const std::string& ClientToServer_StateMachine_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientToServer_StateMachine_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientToServer_StateMachine_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientToServer_StateMachine_State_descriptor(), enum_t_value);
}
inline bool ClientToServer_StateMachine_State_Parse(
    const std::string& name, ClientToServer_StateMachine_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientToServer_StateMachine_State>(
    ClientToServer_StateMachine_State_descriptor(), name, value);
}
enum ClientToServer_ModuleStatus : int {
  ClientToServer_ModuleStatus_START = 0,
  ClientToServer_ModuleStatus_INIT = 1,
  ClientToServer_ModuleStatus_READY = 2,
  ClientToServer_ModuleStatus_CRITICAL_FAILURE = 3,
  ClientToServer_ModuleStatus_ClientToServer_ModuleStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientToServer_ModuleStatus_ClientToServer_ModuleStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientToServer_ModuleStatus_IsValid(int value);
constexpr ClientToServer_ModuleStatus ClientToServer_ModuleStatus_ModuleStatus_MIN = ClientToServer_ModuleStatus_START;
constexpr ClientToServer_ModuleStatus ClientToServer_ModuleStatus_ModuleStatus_MAX = ClientToServer_ModuleStatus_CRITICAL_FAILURE;
constexpr int ClientToServer_ModuleStatus_ModuleStatus_ARRAYSIZE = ClientToServer_ModuleStatus_ModuleStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientToServer_ModuleStatus_descriptor();
template<typename T>
inline const std::string& ClientToServer_ModuleStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientToServer_ModuleStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientToServer_ModuleStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientToServer_ModuleStatus_descriptor(), enum_t_value);
}
inline bool ClientToServer_ModuleStatus_Parse(
    const std::string& name, ClientToServer_ModuleStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientToServer_ModuleStatus>(
    ClientToServer_ModuleStatus_descriptor(), name, value);
}
// ===================================================================

class ServerToClient :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ServerToClient) */ {
 public:
  ServerToClient();
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);
  ServerToClient(ServerToClient&& from) noexcept
    : ServerToClient() {
    *this = ::std::move(from);
  }

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerToClient& operator=(ServerToClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerToClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient* internal_default_instance() {
    return reinterpret_cast<const ServerToClient*>(
               &_ServerToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ServerToClient* other);
  friend void swap(ServerToClient& a, ServerToClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const final {
    return CreateMaybeMessage<ServerToClient>(nullptr);
  }

  ServerToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ServerToClient";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ServerToClient_Command Command;
  static constexpr Command ACK =
    ServerToClient_Command_ACK;
  static constexpr Command STOP =
    ServerToClient_Command_STOP;
  static constexpr Command CALIBRATE =
    ServerToClient_Command_CALIBRATE;
  static constexpr Command LAUNCH =
    ServerToClient_Command_LAUNCH;
  static constexpr Command RESET =
    ServerToClient_Command_RESET;
  static constexpr Command SERVICE_PROPULSION_GO =
    ServerToClient_Command_SERVICE_PROPULSION_GO;
  static constexpr Command SERVICE_PROPULSION_STOP =
    ServerToClient_Command_SERVICE_PROPULSION_STOP;
  static constexpr Command NOMINAL_BRAKING =
    ServerToClient_Command_NOMINAL_BRAKING;
  static inline bool Command_IsValid(int value) {
    return ServerToClient_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    ServerToClient_Command_Command_MIN;
  static constexpr Command Command_MAX =
    ServerToClient_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    ServerToClient_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return ServerToClient_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return ServerToClient_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(const std::string& name,
      Command* value) {
    return ServerToClient_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ServerToClient.Command command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::telemetry_data::ServerToClient_Command command() const;
  void set_command(::telemetry_data::ServerToClient_Command value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ServerToClient)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Navigation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Navigation) */ {
 public:
  ClientToServer_Navigation();
  virtual ~ClientToServer_Navigation();

  ClientToServer_Navigation(const ClientToServer_Navigation& from);
  ClientToServer_Navigation(ClientToServer_Navigation&& from) noexcept
    : ClientToServer_Navigation() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Navigation& operator=(const ClientToServer_Navigation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Navigation& operator=(ClientToServer_Navigation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Navigation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Navigation* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Navigation*>(
               &_ClientToServer_Navigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClientToServer_Navigation* other);
  friend void swap(ClientToServer_Navigation& a, ClientToServer_Navigation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Navigation* New() const final {
    return CreateMaybeMessage<ClientToServer_Navigation>(nullptr);
  }

  ClientToServer_Navigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Navigation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Navigation& from);
  void MergeFrom(const ClientToServer_Navigation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Navigation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Navigation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // float velocity = 3;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  float velocity() const;
  void set_velocity(float value);

  // float acceleration = 4;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 4;
  float acceleration() const;
  void set_acceleration(float value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Navigation)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int module_status_;
  float distance_;
  float velocity_;
  float acceleration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_StateMachine :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.StateMachine) */ {
 public:
  ClientToServer_StateMachine();
  virtual ~ClientToServer_StateMachine();

  ClientToServer_StateMachine(const ClientToServer_StateMachine& from);
  ClientToServer_StateMachine(ClientToServer_StateMachine&& from) noexcept
    : ClientToServer_StateMachine() {
    *this = ::std::move(from);
  }

  inline ClientToServer_StateMachine& operator=(const ClientToServer_StateMachine& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_StateMachine& operator=(ClientToServer_StateMachine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_StateMachine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_StateMachine* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_StateMachine*>(
               &_ClientToServer_StateMachine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientToServer_StateMachine* other);
  friend void swap(ClientToServer_StateMachine& a, ClientToServer_StateMachine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_StateMachine* New() const final {
    return CreateMaybeMessage<ClientToServer_StateMachine>(nullptr);
  }

  ClientToServer_StateMachine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_StateMachine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_StateMachine& from);
  void MergeFrom(const ClientToServer_StateMachine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_StateMachine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.StateMachine";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_StateMachine_State State;
  static constexpr State INVALID =
    ClientToServer_StateMachine_State_INVALID;
  static constexpr State IDLE =
    ClientToServer_StateMachine_State_IDLE;
  static constexpr State CALIBRATING =
    ClientToServer_StateMachine_State_CALIBRATING;
  static constexpr State READY =
    ClientToServer_StateMachine_State_READY;
  static constexpr State ACCELERATING =
    ClientToServer_StateMachine_State_ACCELERATING;
  static constexpr State NOMINAL_BRAKING =
    ClientToServer_StateMachine_State_NOMINAL_BRAKING;
  static constexpr State EMERGENCY_BRAKING =
    ClientToServer_StateMachine_State_EMERGENCY_BRAKING;
  static constexpr State RUN_COMPLETE =
    ClientToServer_StateMachine_State_RUN_COMPLETE;
  static constexpr State FAILURE_STOPPED =
    ClientToServer_StateMachine_State_FAILURE_STOPPED;
  static constexpr State EXITING =
    ClientToServer_StateMachine_State_EXITING;
  static constexpr State FINISHED =
    ClientToServer_StateMachine_State_FINISHED;
  static inline bool State_IsValid(int value) {
    return ClientToServer_StateMachine_State_IsValid(value);
  }
  static constexpr State State_MIN =
    ClientToServer_StateMachine_State_State_MIN;
  static constexpr State State_MAX =
    ClientToServer_StateMachine_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    ClientToServer_StateMachine_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return ClientToServer_StateMachine_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return ClientToServer_StateMachine_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return ClientToServer_StateMachine_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.StateMachine.State current_state = 2;
  void clear_current_state();
  static const int kCurrentStateFieldNumber = 2;
  ::telemetry_data::ClientToServer_StateMachine_State current_state() const;
  void set_current_state(::telemetry_data::ClientToServer_StateMachine_State value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.StateMachine)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int current_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Motors :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Motors) */ {
 public:
  ClientToServer_Motors();
  virtual ~ClientToServer_Motors();

  ClientToServer_Motors(const ClientToServer_Motors& from);
  ClientToServer_Motors(ClientToServer_Motors&& from) noexcept
    : ClientToServer_Motors() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Motors& operator=(const ClientToServer_Motors& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Motors& operator=(ClientToServer_Motors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Motors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Motors* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Motors*>(
               &_ClientToServer_Motors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClientToServer_Motors* other);
  friend void swap(ClientToServer_Motors& a, ClientToServer_Motors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Motors* New() const final {
    return CreateMaybeMessage<ClientToServer_Motors>(nullptr);
  }

  ClientToServer_Motors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Motors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Motors& from);
  void MergeFrom(const ClientToServer_Motors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Motors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Motors";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Motors)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int module_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Batteries_BatteryData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Batteries.BatteryData) */ {
 public:
  ClientToServer_Batteries_BatteryData();
  virtual ~ClientToServer_Batteries_BatteryData();

  ClientToServer_Batteries_BatteryData(const ClientToServer_Batteries_BatteryData& from);
  ClientToServer_Batteries_BatteryData(ClientToServer_Batteries_BatteryData&& from) noexcept
    : ClientToServer_Batteries_BatteryData() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Batteries_BatteryData& operator=(const ClientToServer_Batteries_BatteryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Batteries_BatteryData& operator=(ClientToServer_Batteries_BatteryData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Batteries_BatteryData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Batteries_BatteryData* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Batteries_BatteryData*>(
               &_ClientToServer_Batteries_BatteryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ClientToServer_Batteries_BatteryData* other);
  friend void swap(ClientToServer_Batteries_BatteryData& a, ClientToServer_Batteries_BatteryData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Batteries_BatteryData* New() const final {
    return CreateMaybeMessage<ClientToServer_Batteries_BatteryData>(nullptr);
  }

  ClientToServer_Batteries_BatteryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Batteries_BatteryData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Batteries_BatteryData& from);
  void MergeFrom(const ClientToServer_Batteries_BatteryData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Batteries_BatteryData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Batteries.BatteryData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 indv_voltage = 9;
  int indv_voltage_size() const;
  void clear_indv_voltage();
  static const int kIndvVoltageFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 indv_voltage(int index) const;
  void set_indv_voltage(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_indv_voltage(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      indv_voltage() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_indv_voltage();

  // uint32 voltage = 1;
  void clear_voltage();
  static const int kVoltageFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 voltage() const;
  void set_voltage(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // sint32 current = 2;
  void clear_current();
  static const int kCurrentFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 current() const;
  void set_current(::PROTOBUF_NAMESPACE_ID::int32 value);

  // uint32 charge = 3;
  void clear_charge();
  static const int kChargeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 charge() const;
  void set_charge(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // int32 average_temperature = 4;
  void clear_average_temperature();
  static const int kAverageTemperatureFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 average_temperature() const;
  void set_average_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 low_temperature = 5;
  void clear_low_temperature();
  static const int kLowTemperatureFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 low_temperature() const;
  void set_low_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 high_temperature = 6;
  void clear_high_temperature();
  static const int kHighTemperatureFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 high_temperature() const;
  void set_high_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

  // uint32 low_voltage_cell = 7;
  void clear_low_voltage_cell();
  static const int kLowVoltageCellFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 low_voltage_cell() const;
  void set_low_voltage_cell(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 high_voltage_cell = 8;
  void clear_high_voltage_cell();
  static const int kHighVoltageCellFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 high_voltage_cell() const;
  void set_high_voltage_cell(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Batteries.BatteryData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > indv_voltage_;
  mutable std::atomic<int> _indv_voltage_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 voltage_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_;
  ::PROTOBUF_NAMESPACE_ID::uint32 charge_;
  ::PROTOBUF_NAMESPACE_ID::int32 average_temperature_;
  ::PROTOBUF_NAMESPACE_ID::int32 low_temperature_;
  ::PROTOBUF_NAMESPACE_ID::int32 high_temperature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 low_voltage_cell_;
  ::PROTOBUF_NAMESPACE_ID::uint32 high_voltage_cell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Batteries :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Batteries) */ {
 public:
  ClientToServer_Batteries();
  virtual ~ClientToServer_Batteries();

  ClientToServer_Batteries(const ClientToServer_Batteries& from);
  ClientToServer_Batteries(ClientToServer_Batteries&& from) noexcept
    : ClientToServer_Batteries() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Batteries& operator=(const ClientToServer_Batteries& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Batteries& operator=(ClientToServer_Batteries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Batteries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Batteries* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Batteries*>(
               &_ClientToServer_Batteries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ClientToServer_Batteries* other);
  friend void swap(ClientToServer_Batteries& a, ClientToServer_Batteries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Batteries* New() const final {
    return CreateMaybeMessage<ClientToServer_Batteries>(nullptr);
  }

  ClientToServer_Batteries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Batteries>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Batteries& from);
  void MergeFrom(const ClientToServer_Batteries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Batteries* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Batteries";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_Batteries_BatteryData BatteryData;

  // accessors -------------------------------------------------------

  // repeated .telemetry_data.ClientToServer.Batteries.BatteryData low_power_batteries = 2;
  int low_power_batteries_size() const;
  void clear_low_power_batteries();
  static const int kLowPowerBatteriesFieldNumber = 2;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* mutable_low_power_batteries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
      mutable_low_power_batteries();
  const ::telemetry_data::ClientToServer_Batteries_BatteryData& low_power_batteries(int index) const;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* add_low_power_batteries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
      low_power_batteries() const;

  // repeated .telemetry_data.ClientToServer.Batteries.BatteryData high_power_batteries = 3;
  int high_power_batteries_size() const;
  void clear_high_power_batteries();
  static const int kHighPowerBatteriesFieldNumber = 3;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* mutable_high_power_batteries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
      mutable_high_power_batteries();
  const ::telemetry_data::ClientToServer_Batteries_BatteryData& high_power_batteries(int index) const;
  ::telemetry_data::ClientToServer_Batteries_BatteryData* add_high_power_batteries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
      high_power_batteries() const;

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Batteries)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData > low_power_batteries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData > high_power_batteries_;
  int module_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Sensors_ImuData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Sensors.ImuData) */ {
 public:
  ClientToServer_Sensors_ImuData();
  virtual ~ClientToServer_Sensors_ImuData();

  ClientToServer_Sensors_ImuData(const ClientToServer_Sensors_ImuData& from);
  ClientToServer_Sensors_ImuData(ClientToServer_Sensors_ImuData&& from) noexcept
    : ClientToServer_Sensors_ImuData() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Sensors_ImuData& operator=(const ClientToServer_Sensors_ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Sensors_ImuData& operator=(ClientToServer_Sensors_ImuData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Sensors_ImuData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Sensors_ImuData* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Sensors_ImuData*>(
               &_ClientToServer_Sensors_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ClientToServer_Sensors_ImuData* other);
  friend void swap(ClientToServer_Sensors_ImuData& a, ClientToServer_Sensors_ImuData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Sensors_ImuData* New() const final {
    return CreateMaybeMessage<ClientToServer_Sensors_ImuData>(nullptr);
  }

  ClientToServer_Sensors_ImuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Sensors_ImuData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Sensors_ImuData& from);
  void MergeFrom(const ClientToServer_Sensors_ImuData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Sensors_ImuData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Sensors.ImuData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float acc = 2;
  int acc_size() const;
  void clear_acc();
  static const int kAccFieldNumber = 2;
  float acc(int index) const;
  void set_acc(int index, float value);
  void add_acc(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      acc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_acc();

  // bool operational = 1;
  void clear_operational();
  static const int kOperationalFieldNumber = 1;
  bool operational() const;
  void set_operational(bool value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Sensors.ImuData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > acc_;
  mutable std::atomic<int> _acc_cached_byte_size_;
  bool operational_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Sensors :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Sensors) */ {
 public:
  ClientToServer_Sensors();
  virtual ~ClientToServer_Sensors();

  ClientToServer_Sensors(const ClientToServer_Sensors& from);
  ClientToServer_Sensors(ClientToServer_Sensors&& from) noexcept
    : ClientToServer_Sensors() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Sensors& operator=(const ClientToServer_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Sensors& operator=(ClientToServer_Sensors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Sensors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Sensors* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Sensors*>(
               &_ClientToServer_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ClientToServer_Sensors* other);
  friend void swap(ClientToServer_Sensors& a, ClientToServer_Sensors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Sensors* New() const final {
    return CreateMaybeMessage<ClientToServer_Sensors>(nullptr);
  }

  ClientToServer_Sensors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Sensors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Sensors& from);
  void MergeFrom(const ClientToServer_Sensors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Sensors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Sensors";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_Sensors_ImuData ImuData;

  // accessors -------------------------------------------------------

  // repeated .telemetry_data.ClientToServer.Sensors.ImuData imu = 2;
  int imu_size() const;
  void clear_imu();
  static const int kImuFieldNumber = 2;
  ::telemetry_data::ClientToServer_Sensors_ImuData* mutable_imu(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >*
      mutable_imu();
  const ::telemetry_data::ClientToServer_Sensors_ImuData& imu(int index) const;
  ::telemetry_data::ClientToServer_Sensors_ImuData* add_imu();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >&
      imu() const;

  // .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
  void clear_module_status();
  static const int kModuleStatusFieldNumber = 1;
  ::telemetry_data::ClientToServer_ModuleStatus module_status() const;
  void set_module_status(::telemetry_data::ClientToServer_ModuleStatus value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Sensors)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData > imu_;
  int module_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_Temperature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.Temperature) */ {
 public:
  ClientToServer_Temperature();
  virtual ~ClientToServer_Temperature();

  ClientToServer_Temperature(const ClientToServer_Temperature& from);
  ClientToServer_Temperature(ClientToServer_Temperature&& from) noexcept
    : ClientToServer_Temperature() {
    *this = ::std::move(from);
  }

  inline ClientToServer_Temperature& operator=(const ClientToServer_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_Temperature& operator=(ClientToServer_Temperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_Temperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_Temperature* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_Temperature*>(
               &_ClientToServer_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ClientToServer_Temperature* other);
  friend void swap(ClientToServer_Temperature& a, ClientToServer_Temperature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_Temperature* New() const final {
    return CreateMaybeMessage<ClientToServer_Temperature>(nullptr);
  }

  ClientToServer_Temperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_Temperature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_Temperature& from);
  void MergeFrom(const ClientToServer_Temperature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_Temperature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.Temperature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 temperature = 1;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 temperature() const;
  void set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.Temperature)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 temperature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer_EmergencyBrakes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer.EmergencyBrakes) */ {
 public:
  ClientToServer_EmergencyBrakes();
  virtual ~ClientToServer_EmergencyBrakes();

  ClientToServer_EmergencyBrakes(const ClientToServer_EmergencyBrakes& from);
  ClientToServer_EmergencyBrakes(ClientToServer_EmergencyBrakes&& from) noexcept
    : ClientToServer_EmergencyBrakes() {
    *this = ::std::move(from);
  }

  inline ClientToServer_EmergencyBrakes& operator=(const ClientToServer_EmergencyBrakes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer_EmergencyBrakes& operator=(ClientToServer_EmergencyBrakes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer_EmergencyBrakes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer_EmergencyBrakes* internal_default_instance() {
    return reinterpret_cast<const ClientToServer_EmergencyBrakes*>(
               &_ClientToServer_EmergencyBrakes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClientToServer_EmergencyBrakes* other);
  friend void swap(ClientToServer_EmergencyBrakes& a, ClientToServer_EmergencyBrakes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer_EmergencyBrakes* New() const final {
    return CreateMaybeMessage<ClientToServer_EmergencyBrakes>(nullptr);
  }

  ClientToServer_EmergencyBrakes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer_EmergencyBrakes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer_EmergencyBrakes& from);
  void MergeFrom(const ClientToServer_EmergencyBrakes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer_EmergencyBrakes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer.EmergencyBrakes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool brakes = 1;
  int brakes_size() const;
  void clear_brakes();
  static const int kBrakesFieldNumber = 1;
  bool brakes(int index) const;
  void set_brakes(int index, bool value);
  void add_brakes(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      brakes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_brakes();

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer.EmergencyBrakes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > brakes_;
  mutable std::atomic<int> _brakes_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientToServer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:telemetry_data.ClientToServer) */ {
 public:
  ClientToServer();
  virtual ~ClientToServer();

  ClientToServer(const ClientToServer& from);
  ClientToServer(ClientToServer&& from) noexcept
    : ClientToServer() {
    *this = ::std::move(from);
  }

  inline ClientToServer& operator=(const ClientToServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServer& operator=(ClientToServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientToServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServer* internal_default_instance() {
    return reinterpret_cast<const ClientToServer*>(
               &_ClientToServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ClientToServer* other);
  friend void swap(ClientToServer& a, ClientToServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServer* New() const final {
    return CreateMaybeMessage<ClientToServer>(nullptr);
  }

  ClientToServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientToServer& from);
  void MergeFrom(const ClientToServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "telemetry_data.ClientToServer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClientToServer_Navigation Navigation;
  typedef ClientToServer_StateMachine StateMachine;
  typedef ClientToServer_Motors Motors;
  typedef ClientToServer_Batteries Batteries;
  typedef ClientToServer_Sensors Sensors;
  typedef ClientToServer_Temperature Temperature;
  typedef ClientToServer_EmergencyBrakes EmergencyBrakes;

  typedef ClientToServer_ModuleStatus ModuleStatus;
  static constexpr ModuleStatus START =
    ClientToServer_ModuleStatus_START;
  static constexpr ModuleStatus INIT =
    ClientToServer_ModuleStatus_INIT;
  static constexpr ModuleStatus READY =
    ClientToServer_ModuleStatus_READY;
  static constexpr ModuleStatus CRITICAL_FAILURE =
    ClientToServer_ModuleStatus_CRITICAL_FAILURE;
  static inline bool ModuleStatus_IsValid(int value) {
    return ClientToServer_ModuleStatus_IsValid(value);
  }
  static constexpr ModuleStatus ModuleStatus_MIN =
    ClientToServer_ModuleStatus_ModuleStatus_MIN;
  static constexpr ModuleStatus ModuleStatus_MAX =
    ClientToServer_ModuleStatus_ModuleStatus_MAX;
  static constexpr int ModuleStatus_ARRAYSIZE =
    ClientToServer_ModuleStatus_ModuleStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModuleStatus_descriptor() {
    return ClientToServer_ModuleStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ModuleStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModuleStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModuleStatus_Name.");
    return ClientToServer_ModuleStatus_Name(enum_t_value);
  }
  static inline bool ModuleStatus_Parse(const std::string& name,
      ModuleStatus* value) {
    return ClientToServer_ModuleStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .telemetry_data.ClientToServer.Navigation navigation = 1;
  bool has_navigation() const;
  void clear_navigation();
  static const int kNavigationFieldNumber = 1;
  const ::telemetry_data::ClientToServer_Navigation& navigation() const;
  ::telemetry_data::ClientToServer_Navigation* release_navigation();
  ::telemetry_data::ClientToServer_Navigation* mutable_navigation();
  void set_allocated_navigation(::telemetry_data::ClientToServer_Navigation* navigation);

  // .telemetry_data.ClientToServer.StateMachine state_machine = 2;
  bool has_state_machine() const;
  void clear_state_machine();
  static const int kStateMachineFieldNumber = 2;
  const ::telemetry_data::ClientToServer_StateMachine& state_machine() const;
  ::telemetry_data::ClientToServer_StateMachine* release_state_machine();
  ::telemetry_data::ClientToServer_StateMachine* mutable_state_machine();
  void set_allocated_state_machine(::telemetry_data::ClientToServer_StateMachine* state_machine);

  // .telemetry_data.ClientToServer.Motors motors = 3;
  bool has_motors() const;
  void clear_motors();
  static const int kMotorsFieldNumber = 3;
  const ::telemetry_data::ClientToServer_Motors& motors() const;
  ::telemetry_data::ClientToServer_Motors* release_motors();
  ::telemetry_data::ClientToServer_Motors* mutable_motors();
  void set_allocated_motors(::telemetry_data::ClientToServer_Motors* motors);

  // .telemetry_data.ClientToServer.Batteries batteries = 4;
  bool has_batteries() const;
  void clear_batteries();
  static const int kBatteriesFieldNumber = 4;
  const ::telemetry_data::ClientToServer_Batteries& batteries() const;
  ::telemetry_data::ClientToServer_Batteries* release_batteries();
  ::telemetry_data::ClientToServer_Batteries* mutable_batteries();
  void set_allocated_batteries(::telemetry_data::ClientToServer_Batteries* batteries);

  // .telemetry_data.ClientToServer.Sensors sensors = 5;
  bool has_sensors() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 5;
  const ::telemetry_data::ClientToServer_Sensors& sensors() const;
  ::telemetry_data::ClientToServer_Sensors* release_sensors();
  ::telemetry_data::ClientToServer_Sensors* mutable_sensors();
  void set_allocated_sensors(::telemetry_data::ClientToServer_Sensors* sensors);

  // .telemetry_data.ClientToServer.Temperature temperature = 6;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 6;
  const ::telemetry_data::ClientToServer_Temperature& temperature() const;
  ::telemetry_data::ClientToServer_Temperature* release_temperature();
  ::telemetry_data::ClientToServer_Temperature* mutable_temperature();
  void set_allocated_temperature(::telemetry_data::ClientToServer_Temperature* temperature);

  // .telemetry_data.ClientToServer.EmergencyBrakes emergency_brakes = 7;
  bool has_emergency_brakes() const;
  void clear_emergency_brakes();
  static const int kEmergencyBrakesFieldNumber = 7;
  const ::telemetry_data::ClientToServer_EmergencyBrakes& emergency_brakes() const;
  ::telemetry_data::ClientToServer_EmergencyBrakes* release_emergency_brakes();
  ::telemetry_data::ClientToServer_EmergencyBrakes* mutable_emergency_brakes();
  void set_allocated_emergency_brakes(::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes);

  // @@protoc_insertion_point(class_scope:telemetry_data.ClientToServer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::telemetry_data::ClientToServer_Navigation* navigation_;
  ::telemetry_data::ClientToServer_StateMachine* state_machine_;
  ::telemetry_data::ClientToServer_Motors* motors_;
  ::telemetry_data::ClientToServer_Batteries* batteries_;
  ::telemetry_data::ClientToServer_Sensors* sensors_;
  ::telemetry_data::ClientToServer_Temperature* temperature_;
  ::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerToClient

// .telemetry_data.ServerToClient.Command command = 1;
inline void ServerToClient::clear_command() {
  command_ = 0;
}
inline ::telemetry_data::ServerToClient_Command ServerToClient::command() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ServerToClient.command)
  return static_cast< ::telemetry_data::ServerToClient_Command >(command_);
}
inline void ServerToClient::set_command(::telemetry_data::ServerToClient_Command value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ServerToClient.command)
}

// -------------------------------------------------------------------

// ClientToServer_Navigation

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Navigation::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Navigation::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Navigation::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.module_status)
}

// float distance = 2;
inline void ClientToServer_Navigation::clear_distance() {
  distance_ = 0;
}
inline float ClientToServer_Navigation::distance() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.distance)
  return distance_;
}
inline void ClientToServer_Navigation::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.distance)
}

// float velocity = 3;
inline void ClientToServer_Navigation::clear_velocity() {
  velocity_ = 0;
}
inline float ClientToServer_Navigation::velocity() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.velocity)
  return velocity_;
}
inline void ClientToServer_Navigation::set_velocity(float value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.velocity)
}

// float acceleration = 4;
inline void ClientToServer_Navigation::clear_acceleration() {
  acceleration_ = 0;
}
inline float ClientToServer_Navigation::acceleration() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Navigation.acceleration)
  return acceleration_;
}
inline void ClientToServer_Navigation::set_acceleration(float value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Navigation.acceleration)
}

// -------------------------------------------------------------------

// ClientToServer_StateMachine

// .telemetry_data.ClientToServer.StateMachine.State current_state = 2;
inline void ClientToServer_StateMachine::clear_current_state() {
  current_state_ = 0;
}
inline ::telemetry_data::ClientToServer_StateMachine_State ClientToServer_StateMachine::current_state() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.StateMachine.current_state)
  return static_cast< ::telemetry_data::ClientToServer_StateMachine_State >(current_state_);
}
inline void ClientToServer_StateMachine::set_current_state(::telemetry_data::ClientToServer_StateMachine_State value) {
  
  current_state_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.StateMachine.current_state)
}

// -------------------------------------------------------------------

// ClientToServer_Motors

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Motors::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Motors::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Motors.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Motors::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Motors.module_status)
}

// -------------------------------------------------------------------

// ClientToServer_Batteries_BatteryData

// uint32 voltage = 1;
inline void ClientToServer_Batteries_BatteryData::clear_voltage() {
  voltage_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_Batteries_BatteryData::voltage() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.voltage)
  return voltage_;
}
inline void ClientToServer_Batteries_BatteryData::set_voltage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.voltage)
}

// sint32 current = 2;
inline void ClientToServer_Batteries_BatteryData::clear_current() {
  current_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_Batteries_BatteryData::current() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.current)
  return current_;
}
inline void ClientToServer_Batteries_BatteryData::set_current(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  current_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.current)
}

// uint32 charge = 3;
inline void ClientToServer_Batteries_BatteryData::clear_charge() {
  charge_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_Batteries_BatteryData::charge() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.charge)
  return charge_;
}
inline void ClientToServer_Batteries_BatteryData::set_charge(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.charge)
}

// int32 average_temperature = 4;
inline void ClientToServer_Batteries_BatteryData::clear_average_temperature() {
  average_temperature_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_Batteries_BatteryData::average_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.average_temperature)
  return average_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_average_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  average_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.average_temperature)
}

// int32 low_temperature = 5;
inline void ClientToServer_Batteries_BatteryData::clear_low_temperature() {
  low_temperature_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_Batteries_BatteryData::low_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.low_temperature)
  return low_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_low_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  low_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.low_temperature)
}

// int32 high_temperature = 6;
inline void ClientToServer_Batteries_BatteryData::clear_high_temperature() {
  high_temperature_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_Batteries_BatteryData::high_temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.high_temperature)
  return high_temperature_;
}
inline void ClientToServer_Batteries_BatteryData::set_high_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  high_temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.high_temperature)
}

// uint32 low_voltage_cell = 7;
inline void ClientToServer_Batteries_BatteryData::clear_low_voltage_cell() {
  low_voltage_cell_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_Batteries_BatteryData::low_voltage_cell() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.low_voltage_cell)
  return low_voltage_cell_;
}
inline void ClientToServer_Batteries_BatteryData::set_low_voltage_cell(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  low_voltage_cell_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.low_voltage_cell)
}

// uint32 high_voltage_cell = 8;
inline void ClientToServer_Batteries_BatteryData::clear_high_voltage_cell() {
  high_voltage_cell_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_Batteries_BatteryData::high_voltage_cell() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.high_voltage_cell)
  return high_voltage_cell_;
}
inline void ClientToServer_Batteries_BatteryData::set_high_voltage_cell(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  high_voltage_cell_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.high_voltage_cell)
}

// repeated uint32 indv_voltage = 9;
inline int ClientToServer_Batteries_BatteryData::indv_voltage_size() const {
  return indv_voltage_.size();
}
inline void ClientToServer_Batteries_BatteryData::clear_indv_voltage() {
  indv_voltage_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientToServer_Batteries_BatteryData::indv_voltage(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return indv_voltage_.Get(index);
}
inline void ClientToServer_Batteries_BatteryData::set_indv_voltage(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  indv_voltage_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
}
inline void ClientToServer_Batteries_BatteryData::add_indv_voltage(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  indv_voltage_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ClientToServer_Batteries_BatteryData::indv_voltage() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return indv_voltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ClientToServer_Batteries_BatteryData::mutable_indv_voltage() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.BatteryData.indv_voltage)
  return &indv_voltage_;
}

// -------------------------------------------------------------------

// ClientToServer_Batteries

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Batteries::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Batteries::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Batteries::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Batteries.module_status)
}

// repeated .telemetry_data.ClientToServer.Batteries.BatteryData low_power_batteries = 2;
inline int ClientToServer_Batteries::low_power_batteries_size() const {
  return low_power_batteries_.size();
}
inline void ClientToServer_Batteries::clear_low_power_batteries() {
  low_power_batteries_.Clear();
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::mutable_low_power_batteries(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
ClientToServer_Batteries::mutable_low_power_batteries() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return &low_power_batteries_;
}
inline const ::telemetry_data::ClientToServer_Batteries_BatteryData& ClientToServer_Batteries::low_power_batteries(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Get(index);
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::add_low_power_batteries() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
ClientToServer_Batteries::low_power_batteries() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.low_power_batteries)
  return low_power_batteries_;
}

// repeated .telemetry_data.ClientToServer.Batteries.BatteryData high_power_batteries = 3;
inline int ClientToServer_Batteries::high_power_batteries_size() const {
  return high_power_batteries_.size();
}
inline void ClientToServer_Batteries::clear_high_power_batteries() {
  high_power_batteries_.Clear();
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::mutable_high_power_batteries(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >*
ClientToServer_Batteries::mutable_high_power_batteries() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return &high_power_batteries_;
}
inline const ::telemetry_data::ClientToServer_Batteries_BatteryData& ClientToServer_Batteries::high_power_batteries(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Get(index);
}
inline ::telemetry_data::ClientToServer_Batteries_BatteryData* ClientToServer_Batteries::add_high_power_batteries() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Batteries_BatteryData >&
ClientToServer_Batteries::high_power_batteries() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Batteries.high_power_batteries)
  return high_power_batteries_;
}

// -------------------------------------------------------------------

// ClientToServer_Sensors_ImuData

// bool operational = 1;
inline void ClientToServer_Sensors_ImuData::clear_operational() {
  operational_ = false;
}
inline bool ClientToServer_Sensors_ImuData::operational() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.ImuData.operational)
  return operational_;
}
inline void ClientToServer_Sensors_ImuData::set_operational(bool value) {
  
  operational_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.ImuData.operational)
}

// repeated float acc = 2;
inline int ClientToServer_Sensors_ImuData::acc_size() const {
  return acc_.size();
}
inline void ClientToServer_Sensors_ImuData::clear_acc() {
  acc_.Clear();
}
inline float ClientToServer_Sensors_ImuData::acc(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return acc_.Get(index);
}
inline void ClientToServer_Sensors_ImuData::set_acc(int index, float value) {
  acc_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.ImuData.acc)
}
inline void ClientToServer_Sensors_ImuData::add_acc(float value) {
  acc_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Sensors.ImuData.acc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ClientToServer_Sensors_ImuData::acc() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return acc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ClientToServer_Sensors_ImuData::mutable_acc() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Sensors.ImuData.acc)
  return &acc_;
}

// -------------------------------------------------------------------

// ClientToServer_Sensors

// .telemetry_data.ClientToServer.ModuleStatus module_status = 1;
inline void ClientToServer_Sensors::clear_module_status() {
  module_status_ = 0;
}
inline ::telemetry_data::ClientToServer_ModuleStatus ClientToServer_Sensors::module_status() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.module_status)
  return static_cast< ::telemetry_data::ClientToServer_ModuleStatus >(module_status_);
}
inline void ClientToServer_Sensors::set_module_status(::telemetry_data::ClientToServer_ModuleStatus value) {
  
  module_status_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Sensors.module_status)
}

// repeated .telemetry_data.ClientToServer.Sensors.ImuData imu = 2;
inline int ClientToServer_Sensors::imu_size() const {
  return imu_.size();
}
inline void ClientToServer_Sensors::clear_imu() {
  imu_.Clear();
}
inline ::telemetry_data::ClientToServer_Sensors_ImuData* ClientToServer_Sensors::mutable_imu(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >*
ClientToServer_Sensors::mutable_imu() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.Sensors.imu)
  return &imu_;
}
inline const ::telemetry_data::ClientToServer_Sensors_ImuData& ClientToServer_Sensors::imu(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Get(index);
}
inline ::telemetry_data::ClientToServer_Sensors_ImuData* ClientToServer_Sensors::add_imu() {
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.Sensors.imu)
  return imu_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::telemetry_data::ClientToServer_Sensors_ImuData >&
ClientToServer_Sensors::imu() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.Sensors.imu)
  return imu_;
}

// -------------------------------------------------------------------

// ClientToServer_Temperature

// sint32 temperature = 1;
inline void ClientToServer_Temperature::clear_temperature() {
  temperature_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientToServer_Temperature::temperature() const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.Temperature.temperature)
  return temperature_;
}
inline void ClientToServer_Temperature::set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  temperature_ = value;
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.Temperature.temperature)
}

// -------------------------------------------------------------------

// ClientToServer_EmergencyBrakes

// repeated bool brakes = 1;
inline int ClientToServer_EmergencyBrakes::brakes_size() const {
  return brakes_.size();
}
inline void ClientToServer_EmergencyBrakes::clear_brakes() {
  brakes_.Clear();
}
inline bool ClientToServer_EmergencyBrakes::brakes(int index) const {
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return brakes_.Get(index);
}
inline void ClientToServer_EmergencyBrakes::set_brakes(int index, bool value) {
  brakes_.Set(index, value);
  // @@protoc_insertion_point(field_set:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
}
inline void ClientToServer_EmergencyBrakes::add_brakes(bool value) {
  brakes_.Add(value);
  // @@protoc_insertion_point(field_add:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ClientToServer_EmergencyBrakes::brakes() const {
  // @@protoc_insertion_point(field_list:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return brakes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ClientToServer_EmergencyBrakes::mutable_brakes() {
  // @@protoc_insertion_point(field_mutable_list:telemetry_data.ClientToServer.EmergencyBrakes.brakes)
  return &brakes_;
}

// -------------------------------------------------------------------

// ClientToServer

// .telemetry_data.ClientToServer.Navigation navigation = 1;
inline bool ClientToServer::has_navigation() const {
  return this != internal_default_instance() && navigation_ != nullptr;
}
inline void ClientToServer::clear_navigation() {
  if (GetArenaNoVirtual() == nullptr && navigation_ != nullptr) {
    delete navigation_;
  }
  navigation_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_Navigation& ClientToServer::navigation() const {
  const ::telemetry_data::ClientToServer_Navigation* p = navigation_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.navigation)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Navigation*>(
      &::telemetry_data::_ClientToServer_Navigation_default_instance_);
}
inline ::telemetry_data::ClientToServer_Navigation* ClientToServer::release_navigation() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.navigation)
  
  ::telemetry_data::ClientToServer_Navigation* temp = navigation_;
  navigation_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_Navigation* ClientToServer::mutable_navigation() {
  
  if (navigation_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Navigation>(GetArenaNoVirtual());
    navigation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.navigation)
  return navigation_;
}
inline void ClientToServer::set_allocated_navigation(::telemetry_data::ClientToServer_Navigation* navigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete navigation_;
  }
  if (navigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigation, submessage_arena);
    }
    
  } else {
    
  }
  navigation_ = navigation;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.navigation)
}

// .telemetry_data.ClientToServer.StateMachine state_machine = 2;
inline bool ClientToServer::has_state_machine() const {
  return this != internal_default_instance() && state_machine_ != nullptr;
}
inline void ClientToServer::clear_state_machine() {
  if (GetArenaNoVirtual() == nullptr && state_machine_ != nullptr) {
    delete state_machine_;
  }
  state_machine_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_StateMachine& ClientToServer::state_machine() const {
  const ::telemetry_data::ClientToServer_StateMachine* p = state_machine_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.state_machine)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_StateMachine*>(
      &::telemetry_data::_ClientToServer_StateMachine_default_instance_);
}
inline ::telemetry_data::ClientToServer_StateMachine* ClientToServer::release_state_machine() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.state_machine)
  
  ::telemetry_data::ClientToServer_StateMachine* temp = state_machine_;
  state_machine_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_StateMachine* ClientToServer::mutable_state_machine() {
  
  if (state_machine_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_StateMachine>(GetArenaNoVirtual());
    state_machine_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.state_machine)
  return state_machine_;
}
inline void ClientToServer::set_allocated_state_machine(::telemetry_data::ClientToServer_StateMachine* state_machine) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_machine_;
  }
  if (state_machine) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state_machine = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_machine, submessage_arena);
    }
    
  } else {
    
  }
  state_machine_ = state_machine;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.state_machine)
}

// .telemetry_data.ClientToServer.Motors motors = 3;
inline bool ClientToServer::has_motors() const {
  return this != internal_default_instance() && motors_ != nullptr;
}
inline void ClientToServer::clear_motors() {
  if (GetArenaNoVirtual() == nullptr && motors_ != nullptr) {
    delete motors_;
  }
  motors_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_Motors& ClientToServer::motors() const {
  const ::telemetry_data::ClientToServer_Motors* p = motors_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.motors)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Motors*>(
      &::telemetry_data::_ClientToServer_Motors_default_instance_);
}
inline ::telemetry_data::ClientToServer_Motors* ClientToServer::release_motors() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.motors)
  
  ::telemetry_data::ClientToServer_Motors* temp = motors_;
  motors_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_Motors* ClientToServer::mutable_motors() {
  
  if (motors_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Motors>(GetArenaNoVirtual());
    motors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.motors)
  return motors_;
}
inline void ClientToServer::set_allocated_motors(::telemetry_data::ClientToServer_Motors* motors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete motors_;
  }
  if (motors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      motors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motors, submessage_arena);
    }
    
  } else {
    
  }
  motors_ = motors;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.motors)
}

// .telemetry_data.ClientToServer.Batteries batteries = 4;
inline bool ClientToServer::has_batteries() const {
  return this != internal_default_instance() && batteries_ != nullptr;
}
inline void ClientToServer::clear_batteries() {
  if (GetArenaNoVirtual() == nullptr && batteries_ != nullptr) {
    delete batteries_;
  }
  batteries_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_Batteries& ClientToServer::batteries() const {
  const ::telemetry_data::ClientToServer_Batteries* p = batteries_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.batteries)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Batteries*>(
      &::telemetry_data::_ClientToServer_Batteries_default_instance_);
}
inline ::telemetry_data::ClientToServer_Batteries* ClientToServer::release_batteries() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.batteries)
  
  ::telemetry_data::ClientToServer_Batteries* temp = batteries_;
  batteries_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_Batteries* ClientToServer::mutable_batteries() {
  
  if (batteries_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Batteries>(GetArenaNoVirtual());
    batteries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.batteries)
  return batteries_;
}
inline void ClientToServer::set_allocated_batteries(::telemetry_data::ClientToServer_Batteries* batteries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete batteries_;
  }
  if (batteries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      batteries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batteries, submessage_arena);
    }
    
  } else {
    
  }
  batteries_ = batteries;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.batteries)
}

// .telemetry_data.ClientToServer.Sensors sensors = 5;
inline bool ClientToServer::has_sensors() const {
  return this != internal_default_instance() && sensors_ != nullptr;
}
inline void ClientToServer::clear_sensors() {
  if (GetArenaNoVirtual() == nullptr && sensors_ != nullptr) {
    delete sensors_;
  }
  sensors_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_Sensors& ClientToServer::sensors() const {
  const ::telemetry_data::ClientToServer_Sensors* p = sensors_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.sensors)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Sensors*>(
      &::telemetry_data::_ClientToServer_Sensors_default_instance_);
}
inline ::telemetry_data::ClientToServer_Sensors* ClientToServer::release_sensors() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.sensors)
  
  ::telemetry_data::ClientToServer_Sensors* temp = sensors_;
  sensors_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_Sensors* ClientToServer::mutable_sensors() {
  
  if (sensors_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Sensors>(GetArenaNoVirtual());
    sensors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.sensors)
  return sensors_;
}
inline void ClientToServer::set_allocated_sensors(::telemetry_data::ClientToServer_Sensors* sensors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensors_;
  }
  if (sensors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensors, submessage_arena);
    }
    
  } else {
    
  }
  sensors_ = sensors;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.sensors)
}

// .telemetry_data.ClientToServer.Temperature temperature = 6;
inline bool ClientToServer::has_temperature() const {
  return this != internal_default_instance() && temperature_ != nullptr;
}
inline void ClientToServer::clear_temperature() {
  if (GetArenaNoVirtual() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_Temperature& ClientToServer::temperature() const {
  const ::telemetry_data::ClientToServer_Temperature* p = temperature_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.temperature)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_Temperature*>(
      &::telemetry_data::_ClientToServer_Temperature_default_instance_);
}
inline ::telemetry_data::ClientToServer_Temperature* ClientToServer::release_temperature() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.temperature)
  
  ::telemetry_data::ClientToServer_Temperature* temp = temperature_;
  temperature_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_Temperature* ClientToServer::mutable_temperature() {
  
  if (temperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_Temperature>(GetArenaNoVirtual());
    temperature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.temperature)
  return temperature_;
}
inline void ClientToServer::set_allocated_temperature(::telemetry_data::ClientToServer_Temperature* temperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete temperature_;
  }
  if (temperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      temperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.temperature)
}

// .telemetry_data.ClientToServer.EmergencyBrakes emergency_brakes = 7;
inline bool ClientToServer::has_emergency_brakes() const {
  return this != internal_default_instance() && emergency_brakes_ != nullptr;
}
inline void ClientToServer::clear_emergency_brakes() {
  if (GetArenaNoVirtual() == nullptr && emergency_brakes_ != nullptr) {
    delete emergency_brakes_;
  }
  emergency_brakes_ = nullptr;
}
inline const ::telemetry_data::ClientToServer_EmergencyBrakes& ClientToServer::emergency_brakes() const {
  const ::telemetry_data::ClientToServer_EmergencyBrakes* p = emergency_brakes_;
  // @@protoc_insertion_point(field_get:telemetry_data.ClientToServer.emergency_brakes)
  return p != nullptr ? *p : *reinterpret_cast<const ::telemetry_data::ClientToServer_EmergencyBrakes*>(
      &::telemetry_data::_ClientToServer_EmergencyBrakes_default_instance_);
}
inline ::telemetry_data::ClientToServer_EmergencyBrakes* ClientToServer::release_emergency_brakes() {
  // @@protoc_insertion_point(field_release:telemetry_data.ClientToServer.emergency_brakes)
  
  ::telemetry_data::ClientToServer_EmergencyBrakes* temp = emergency_brakes_;
  emergency_brakes_ = nullptr;
  return temp;
}
inline ::telemetry_data::ClientToServer_EmergencyBrakes* ClientToServer::mutable_emergency_brakes() {
  
  if (emergency_brakes_ == nullptr) {
    auto* p = CreateMaybeMessage<::telemetry_data::ClientToServer_EmergencyBrakes>(GetArenaNoVirtual());
    emergency_brakes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:telemetry_data.ClientToServer.emergency_brakes)
  return emergency_brakes_;
}
inline void ClientToServer::set_allocated_emergency_brakes(::telemetry_data::ClientToServer_EmergencyBrakes* emergency_brakes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete emergency_brakes_;
  }
  if (emergency_brakes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      emergency_brakes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emergency_brakes, submessage_arena);
    }
    
  } else {
    
  }
  emergency_brakes_ = emergency_brakes;
  // @@protoc_insertion_point(field_set_allocated:telemetry_data.ClientToServer.emergency_brakes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace telemetry_data

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::telemetry_data::ServerToClient_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ServerToClient_Command>() {
  return ::telemetry_data::ServerToClient_Command_descriptor();
}
template <> struct is_proto_enum< ::telemetry_data::ClientToServer_StateMachine_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ClientToServer_StateMachine_State>() {
  return ::telemetry_data::ClientToServer_StateMachine_State_descriptor();
}
template <> struct is_proto_enum< ::telemetry_data::ClientToServer_ModuleStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry_data::ClientToServer_ModuleStatus>() {
  return ::telemetry_data::ClientToServer_ModuleStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
